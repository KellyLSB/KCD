#!/usr/bin/env ruby

# KCD Directory / Path Changer
# Copyright (c) 2012 Kelly Becker
# http://github.com/KellyLSB/KCD
# http://kellybecker.me

require 'fileutils'
require 'net/http'
require 'yaml'

# Version of the Software
_version = '0.1.1'

# Bash Files
BASH_FILES = ['.zshrc', '.bash_profile', '.bashrc'].collect{|f| File.join(Dir.home, f)}

# Bash function used with kcd
BASH_FUNCTION = <<-FUNCTION
### KCD ###
function cd () {
	builtin cd "$@" && kcd "$$";

	if [ -f "`pwd`/.pathSource" ]
		then
			source "`pwd`/.pathSource" && rm "`pwd`/.pathSource";
	fi
}
cd .
### END KCD ###
FUNCTION

# Find KCD code
KCD_REGEX = /### KCD ###(.*?)### END KCD ###/m

# KCD home config directory
KCD_DIR = File.join(Dir.home, '.kcd')

# Place shell extension
def install_shell_extension
	# Append to files
	BASH_FILES.each do |file|
		next if !File.exists?(file)

		# Append the function to the shell
		File.open(file, 'a') do |f|
			f.puts "\n" + BASH_FUNCTION
		end
	end
end

# Remove shell extension
def uninstall_shell_extension
	# Append to files
	BASH_FILES.each do |file|
		next if !File.exists?(file)

		data = File.read(file).gsub(KCD_REGEX, '')

		# Rewrite
		File.open(file, 'w'){|f| f.write data.strip + "\n"}
	end
end

# Command
COMMAND = ARGV.first

# Installer
if COMMAND == '--install'

	if Dir.exists?(KCD_DIR)
		puts "KCD is already installed..."
		exit
	else
		# Make the home config directory
		Dir.mkdir(KCD_DIR)
	end

	# Install shell extension
	puts "Installing KCD Shell Extension"
	install_shell_extension

	# Check to see if were running this file from /usr/local/bin
	# If not go ahread and copy it there and delete the current
	puts "Installing at /usr/local/bin/kcd"
	path = ENV['PATH'].split(':')
	unless path.include? File.dirname(__FILE__)
		system('cp ' + __FILE__ + ' /usr/local/bin/ && rm ' + __FILE__ + ';')
	end

	# Notify of installation
	puts "KCD is now installed..."

	# Generate the cache hash
	system("touch #{KCD_DIR}/cache")
	system("touch #{KCD_DIR}/check_update")
	exit

# Updater
elsif COMMAND == '--update'

	# Notify of download
	puts "Downloading latest KCD..."

	# Download latest shell script
	kcd = `curl -s "https://raw.github.com/KellyLSB/KCD/master/kcd"`.strip

	# Write updated version to /usr/local/bin
	puts "Updating /usr/local/bin/kcd"
	File.open("/usr/local/bin/kcd", "w"){|f| f.write kcd}

	# Run after update tasks
	puts `/usr/local/bin/kcd --after-update`

	# Notify of completion
	puts "Done..."
	exit

# After update script ... Run migrations...
elsif COMMAND == '--after-update'
	puts "Removing old KCD Shell Extension"
	uninstall_shell_extension
	puts "Adding new KCD Shell Extension"
	install_shell_extension
	exit

# After update script ... Run migrations...
elsif COMMAND == '--uninstall'
	puts "Removing KCD Shell Extension"
	uninstall_shell_extension
	puts "Removing Configuration Directory"
	FileUtils.rm_rf(KCD_DIR)
	puts "Removing /usr/local/bin/kcd"
	File.delete('/usr/local/bin/kcd')
	exit
end

# Remind about an update
if File.open(File.join(KCD_DIR, 'check_update')).ctime < (Time.now - 86400)
	begin
		if `curl -s "https://raw.github.com/KellyLSB/KCD/master/version.txt"`.strip != _version
			puts "There is an update for kcd. Run 'kcd --update'"
		end
	rescue => e
		# If an exception is thrown ignore
	end

	# Touch the file so we know we have checked for an update recently
	system("touch #{KCD_DIR}/check_update")
end

#==================================#
#=========== Versioning ===========#
#==================================#

# Process ID (Based as an argument)
shell_pid = COMMAND
if shell_pid.to_s.match(/\A[+-]?\d+?(\.\d+)?\Z/).nil?
	shell_pid = nil
end

# Get current directory
current_dir = `pwd`.strip
current_dir_split = current_dir.split('/')

# Find a directory with a .path in it
directory_segs = current_dir_split.length
i = 1; while i < directory_segs
	pathDir = current_dir_split.join('/')
	break if File.exists?(File.join(pathDir, '.path'))
	current_dir_split.pop
	pathDir = nil
	i += 1
end

# Load KCD cache
cache = YAML::load(File.new(File.join(KCD_DIR, 'cache'), "r").read)
cache = Hash.new if cache == false || cache.nil? || cache.empty?

# Use a cache for this shell instance if possible
unless shell_pid.nil?
	cache[shell_pid] = Hash.new unless cache[shell_pid].is_a?(Hash)
	shell_cache = cache[shell_pid]
else
	cache['default'] = Hash.new unless cache['default'].is_a?(Hash)
	shell_cache = cache['default']
end

# If we have a pathfile
unless pathDir.nil?

	# Backup the current path
	backUp = File.dirname(pathDir)
	shell_cache[backUp] = ENV['PATH']

	# Create file for us to source new path with
	File.open(File.join(current_dir, '.pathSource'), "w+") do |f|
		f.write 'export PATH="' + File.open(File.join(pathDir, '.path'), 'r').read.strip + ':' + ENV['PATH'] + '"'
	end
else

	# Check if the current dir had a cached key
	contain = nil
	shell_cache.keys.each do |key|
		next unless key.include? current_dir
		contain = key
	end

	# If there is a cached key restore
	unless contain.nil?
		path = shell_cache[contain]

		# Write path file to source
		File.open(File.join(current_dir, '.pathSource'), "w+") do |f|
			f.write 'export PATH="' + path + '"'
		end

		# Delete the key
		shell_cache.delete(contain)
	end
end

# Mixin the namespaces back into the cache
unless shell_pid.nil?
	cache[shell_pid] = shell_cache
else
	cache['default'] = shell_cache
end

# Delete any empty caches
cache.delete_if do |key, val|

	# Check if PID is alive
	begin
		Process.kill 0, key.to_i if key != 'default'
		remove = false
	rescue
		remove = true
	end

	# Remove any caches that are empty or dead
	val.empty? || remove
end

# Write any changes to the cache
File.open(File.join(KCD_DIR, 'cache'), "w") do |f|
	f.write YAML::dump(cache)
end