#!/usr/local/bin/ruby
require 'net/http'
require 'yaml'

# Version of the Software
_version = '0.0.2'

# Bash function used with kcd
bash_function = <<-FUNCTION
### KCD ###
function cd () {
	builtin cd "$@" && kcd;

	if [ -f "`pwd`/.pathSource" ]
		then
			source "`pwd`/.pathSource" && rm "`pwd`/.pathSource";
	fi
}
### END KCD ###
FUNCTION

# KCD home config directory
kcd_dir = File.join(Dir.home, '.kcd')

# Installer
if ARGV.first == '--install'

	if Dir.exists?(kcd_dir)
		puts "KCD is already installed..."
		exit
	else
		# Make the home config directory
		Dir.mkdir(kcd_dir)
	end

	# Figure out which file to add the function to
	if File.exists?(File.join(Dir.home, '.zshrc'))
		file = File.join(Dir.home, '.zshrc')
	elsif File.exists?(File.join(Dir.home, '.bash_profile'))
		file = File.join(Dir.home, '.bash_profile')
	elsif File.exists?(File.join(Dir.home, '.bashrc'))
		file = File.join(Dir.home, '.bashrc')
	else
		file = nil
	end

	# Append the function to the shell
	File.open(file, 'a') do |f|
  		f.puts "\n" + bash_function
	end unless file.nil?

	# Check to see if were running this file from /usr/local/bin
	# If not go ahread and copy it there and delete the current
	path = ENV['PATH'].split(':')
	unless path.include? File.dirname(__FILE__)
		system('cp ' + __FILE__ + ' /usr/local/bin/ && rm ' + __FILE__ + ';')
	end

	# Notify of installation
	puts "KCD is now installed..."

	# Generate the cache hash
	system("touch #{kcd_dir}/cache")
	system("touch #{kcd_dir}/check_update")
	exit
end

# Updater
if ARGV.first == '--update'

	# Notify of download
	puts "Downloading latest KCD..."

	# Download latest shell script
	kcd = `curl -s "https://raw.github.com/KellyLSB/KCD/master/kcd"`.strip

	# Write updated version to /usr/local/bin
	File.open("/usr/local/bin/kcd", "w"){|f| f.write kcd}

	# Run after update tasks
	system("kcd --after-update")

	# Notify of completion
	puts "Done..."
	exit
end

# After update script ... Run migrations...
if ARGV.first == '--after-update'
	# Update CD Function etc...
	exit
end

# Remind about an update
if File.open(File.join(kcd_dir, 'check_update')).ctime < (Time.now - 86400)
	if `curl -s "https://raw.github.com/KellyLSB/KCD/master/version.txt"`.strip != _version
		puts "There is an update for kcd. Run 'kcd --update'"
	end
	system("touch #{kcd_dir}/check_update")
end

#==================================#
#=========== Versioning ===========#
#==================================#

# Get current directory
current_dir = `pwd`.strip
current_dir_split = current_dir.split('/')

# Find a directory with a .path in it
directory_segs = current_dir_split.length
i = 1; while i < directory_segs
	pathDir = current_dir_split.join('/')
	break if File.exists?(File.join(pathDir, '.path'))
	current_dir_split.pop
	pathDir = nil
	i += 1
end

# Load KCD cache
cache = YAML::load(File.new(File.join(kcd_dir, 'cache'), "r").read)
cache = Hash.new if cache == false || cache.nil? || cache.empty?

# If we have a pathfile
unless pathDir.nil?

	# Backup the current path
	backUp = File.dirname(pathDir)
	cache[backUp] = ENV['PATH']

	# Create file for us to source new path with
	File.open(File.join(current_dir, '.pathSource'), "w+") do |f|
		f.write 'export PATH="' + File.new(File.join(pathDir, '.path'), "r").read.strip + ':' + ENV['PATH'] + '"'
	end
else

	# Check if the current dir had a cached key
	contain = nil
	cache.keys.each do |key|
		next unless key.include? current_dir
		contain = key
	end

	# If there is a cached key restore
	unless contain.nil?
		path = cache[contain]

		# Write path file to source
		File.open(File.join(current_dir, '.pathSource'), "w+") do |f|
			f.write 'export PATH="' + path + '"'
		end

		# Delete the key
		cache.delete(contain)
	end
end

# Write any changes to the cache
File.open(File.join(kcd_dir, 'cache'), "w") do |f|
	f.write YAML::dump(cache)
end